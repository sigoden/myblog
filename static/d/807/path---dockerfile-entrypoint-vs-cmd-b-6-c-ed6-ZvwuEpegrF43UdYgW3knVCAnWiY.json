{"data":{"site":{"siteMetadata":{"title":"Sigoden | Blog","siteUrl":"https://blog.sigoden.com","siteAuthor":"sigoden","githubUrl":"https://github.com/sigoden"}},"markdownRemark":{"html":"<h2 id=\"概述\"><a href=\"#%E6%A6%82%E8%BF%B0\" aria-label=\"概述 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>概述</h2>\n<p>Dockerfile 中的 ENTRYPOINT 指令和 CMD 指令都可以设置容器启动时要执行的命令。</p>\n<p>ENTRYPOINT 有两种形式:</p>\n<ul>\n<li>exec 模式，如 <code class=\"language-text\">ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</code></li>\n<li>shell 模式, 如 <code class=\"language-text\">ENTRYPOINT command param1 param2</code></li>\n</ul>\n<p>而 CMD 也有两种形式:</p>\n<ul>\n<li>\n<p>exec 模式，如 <code class=\"language-text\">CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;]</code></p>\n<ul>\n<li>当有 entrypoint 时，executable 等价于 param, 官方手册将其也作为了一种模式，严格来讲这仍是 exec 模式。</li>\n</ul>\n</li>\n<li>shell 模式，<code class=\"language-text\">CMD command param1 param2</code></li>\n</ul>\n<h2 id=\"实验过程\"><a href=\"#%E5%AE%9E%E9%AA%8C%E8%BF%87%E7%A8%8B\" aria-label=\"实验过程 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>实验过程</h2>\n<p>为了研究它们的不同之处，我们通过实验，任意组合各种情形，分析其执行结果。</p>\n<p>ENTRYPOINT 和 CMD 分别有好多种情形，彼此间的组合情况更多，为了简化描述，我们引入代号。</p>\n<p>规则如下:</p>\n<ul>\n<li>e -> 表示 ENTRYPOINT</li>\n<li>c -> 表示 CMD</li>\n<li>0 -> 表示 Dockerfile 中没有指令。</li>\n<li>1 -> 表示 Dockerfile 中指令采用 exec 形式，且仅有一个参数。</li>\n<li>2 -> 表示 Dockerfile 中指令采用 shell 形式，且仅由一个参数。</li>\n<li>3 -> 表示 Dockerfile 中指令采用 exec 形式, 有多个参数。</li>\n<li>4 -> 表示 Dockerfile 中指令采用 shell 形式, 有多个参数。</li>\n</ul>\n<p>举例说明，e1c1 表示 Dockerfile 中同时存在 ENTRYPOINT 和 CMD，且是 exec 形式，仅用一个参数。\n其 Dockerfile 如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">// ./Dockerfile.e1c1\n\nFROM alpine\n\nCOPY ./mycmd /usr/bin/\n\nENTRYPOINT [&quot;/usr/bin/mycmd&quot;]\n\nCMD [&quot;arg&quot;]</code></pre></div>\n<p>mycmd 命令用来打印命令行参数，其内容如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">#!/bin/sh\n\necho $@</code></pre></div>\n<p>实验中任意组合各种情况下的 ENTRYPOINT 和 CMD, 生成 Dockerfile。</p>\n<p>创建和执行过程：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">docker build -t e1c1 -f Dockerfile.e1c1 .\ndocker run -rm e1c1 \ndocker run -rm e1c1 a</code></pre></div>\n<p>收集 <code class=\"language-text\">docker run</code> 的输出，可以得到下表：</p>\n<table>\n<thead>\n<tr>\n<th>N.O.</th>\n<th>ENTRYPOINT</th>\n<th>CMD</th>\n<th>RUN</th>\n<th>OUPUT</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>e1c1</td>\n<td>[\"/usr/bin/mycmd\"]</td>\n<td>[\"arg\"]</td>\n<td></td>\n<td>arg</td>\n</tr>\n<tr>\n<td></td>\n<td>[\"/usr/bin/mycmd\"]</td>\n<td>[\"arg\"]</td>\n<td>a</td>\n<td>a</td>\n</tr>\n<tr>\n<td>e1c0</td>\n<td>[\"/usr/bin/mycmd\"]</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>[\"/usr/bin/mycmd\"]</td>\n<td></td>\n<td>a</td>\n<td>a</td>\n</tr>\n<tr>\n<td>e1c2</td>\n<td>[\"/usr/bin/mycmd\"]</td>\n<td>arg</td>\n<td></td>\n<td>/bin/sh -c \"arg\"</td>\n</tr>\n<tr>\n<td></td>\n<td>[\"/usr/bin/mycmd\"]</td>\n<td>arg</td>\n<td>a</td>\n<td>a</td>\n</tr>\n<tr>\n<td>e2c0</td>\n<td>/usr/bin/mycmd</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>/usr/bin/mycmd</td>\n<td></td>\n<td>a</td>\n<td></td>\n</tr>\n<tr>\n<td>e2c1</td>\n<td>/usr/bin/mycmd</td>\n<td>[\"arg\"]</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>/usr/bin/mycmd</td>\n<td>[\"arg\"]</td>\n<td>a</td>\n<td></td>\n</tr>\n<tr>\n<td>e2c2</td>\n<td>/usr/bin/mycmd</td>\n<td>arg</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>/usr/bin/mycmd</td>\n<td>arg</td>\n<td>a</td>\n<td></td>\n</tr>\n<tr>\n<td>e0c0</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td>a</td>\n<td>docker: Error...\"exec: \"a\": executable file not found...</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td>mycmd  a</td>\n<td>a</td>\n</tr>\n<tr>\n<td>e0c1</td>\n<td></td>\n<td>[\"mycmd\"]</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td>[\"mycmd\"]</td>\n<td>a</td>\n<td>docker: Error...\"exec: \"a\": executable file not found...</td>\n</tr>\n<tr>\n<td>e0c2</td>\n<td></td>\n<td>mycmd</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td>mycmd</td>\n<td>a</td>\n<td>docker: Error...\"exec: \"a\": executable file not found...</td>\n</tr>\n<tr>\n<td>e0c3</td>\n<td></td>\n<td>[\"mycmd\", \"a\"]</td>\n<td></td>\n<td>a</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td>[\"mycmd\", \"a\"]</td>\n<td>a</td>\n<td>docker: Error...\"exec: \"a\": executable file not found...</td>\n</tr>\n<tr>\n<td>e0c4</td>\n<td></td>\n<td>mycmd a</td>\n<td></td>\n<td>a</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td>mycmd a</td>\n<td>a</td>\n<td>docker: Error...\"exec: \"a\": executable file not found...</td>\n</tr>\n<tr>\n<td>e3c0</td>\n<td>[\"/usr/bin/mycmd\", \"a\"]</td>\n<td></td>\n<td></td>\n<td>a</td>\n</tr>\n<tr>\n<td></td>\n<td>[\"/usr/bin/mycmd\", \"a\"]</td>\n<td></td>\n<td>b</td>\n<td>a b</td>\n</tr>\n<tr>\n<td>e3c1</td>\n<td>[\"/usr/bin/mycmd\", \"a\"]</td>\n<td>[\"b\"]</td>\n<td></td>\n<td>a b</td>\n</tr>\n<tr>\n<td></td>\n<td>[\"/usr/bin/mycmd\", \"a\"]</td>\n<td>[\"b\"]</td>\n<td>c</td>\n<td>a c</td>\n</tr>\n<tr>\n<td>e3c2</td>\n<td>[\"/usr/bin/mycmd\", \"a\"]</td>\n<td>b</td>\n<td></td>\n<td>a /bin/sh -c \"b\"</td>\n</tr>\n<tr>\n<td></td>\n<td>[\"/usr/bin/mycmd\", \"a\"]</td>\n<td>b</td>\n<td>c</td>\n<td>a c</td>\n</tr>\n<tr>\n<td>e4c0</td>\n<td>/usr/bin/mycmd a</td>\n<td></td>\n<td></td>\n<td>a</td>\n</tr>\n<tr>\n<td></td>\n<td>/usr/bin/mycmd a</td>\n<td></td>\n<td>b</td>\n<td>a</td>\n</tr>\n<tr>\n<td>e4c1</td>\n<td>/usr/bin/mycmd a</td>\n<td>[\"b\"]</td>\n<td></td>\n<td>b: line 1: /usr/bin/mycmd a: not found</td>\n</tr>\n<tr>\n<td></td>\n<td>/usr/bin/mycmd a</td>\n<td>[\"b\"]</td>\n<td>c</td>\n<td>c: line 1: /usr/bin/mycmd a: not found</td>\n</tr>\n<tr>\n<td>e4c2</td>\n<td>/usr/bin/mycmd a</td>\n<td>b</td>\n<td></td>\n<td>/bin/sh: line 1: /usr/bin/mycmd a: not found</td>\n</tr>\n<tr>\n<td></td>\n<td>/usr/bin/mycmd a</td>\n<td>b</td>\n<td>c</td>\n<td>c: line 1: /usr/bin/mycmd a: not found</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>N.O. -> 组合情形编号。</li>\n<li>ENTRYPOINT -> Dockerfile 中指令 ENTRYPOINT 的值。</li>\n<li>CMD ->  Dockerfile 中指令 CMD 的值。</li>\n<li>RUN 表示执行时传递给容器的值。</li>\n<li>OUTPUT 时执行后打印的结果。</li>\n</ul>\n<h2 id=\"结论\"><a href=\"#%E7%BB%93%E8%AE%BA\" aria-label=\"结论 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>结论</h2>\n<ul>\n<li>e2 时 cmd 值全部无效，可以得出 <strong>ENTRYPOINT 采用 shell 模式且没有参数时会忽略 cmd</strong> 。</li>\n<li>e4 有 cmd 值全部报错，可以得出 <strong>ENTRYPOINT 采用 shell 模式有参数时传入 cmd 会报错</strong> 。</li>\n<li>从 e2 和 e4 可以看出， <strong>推荐使用 exec 模式配置 ENTRYPOINT</strong> ，它接受 cmd 且更安全。</li>\n<li>docker run 中 <strong>命令行传入的 cmd 会覆盖 Dockerfile 中的 CMD</strong>。</li>\n<li>根据 e1c2 和 e3c2， <strong>Dockerfile 中 CMD 在 shell 模式下内部会被转换为前部拼接 [\"/bin/sh\", \"-c\"] 的 exec 模式</strong>。</li>\n<li>结合 e1c2 和 e3c2,  <strong>推荐使用 exec 模式配置 CMD</strong> 。</li>\n<li>从 e3 可以得出： <strong>Dockerfile 中的 ENTRYPOINT 在 exec 模式下自带的参数会与 cmd 参数拼接</strong></li>\n</ul>","excerpt":"概述 Dockerfile 中的 ENTRYPOINT 指令和 CMD 指令都可以设置容器启动时要执行的命令。 ENTRYPOINT 有两种形式: exec 模式，如  shell 模式, 如  而 CMD 也有两种形式: exec 模式，如  当有 entrypoint…","timeToRead":5,"headings":[{"value":"概述","depth":2},{"value":"实验过程","depth":2},{"value":"结论","depth":2}],"frontmatter":{"title":"对比分析 Dockerfile 中的 ENTRYPOINT 和 CMD","notoc":true,"excerpt":"Dockerfile 中的 ENTRYPOINT 指令和 CMD 指令都可以设置容器启动时要执行的命令，但用途是有略微不同的，本文将通过实验分析它们的不同之处，给出最佳实践。","date":"November 15th 2017","rawDate":"2017-11-15"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/dockerfile-entrypoint-vs-cmd/","prev":{"fields":{"slug":"/how-to-use-gatsby/"},"frontmatter":{"title":"使用 Gatsby 创建静态站点","draft":null,"tags":["howto","react","graphql"]}},"next":{"fields":{"slug":"/docker-faq/"},"frontmatter":{"title":"Docker 一问一答","draft":false,"tags":["faq","docker"]}}}}