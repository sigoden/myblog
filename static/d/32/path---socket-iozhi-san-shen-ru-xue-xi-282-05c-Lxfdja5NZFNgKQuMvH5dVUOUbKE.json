{"data":{"site":{"siteMetadata":{"title":"Sigoden | Blog","siteUrl":"https://blog.sigoden.com","siteAuthor":"sigoden","githubUrl":"https://github.com/sigoden"}},"markdownRemark":{"html":"<h2 id=\"静态文件\"><a href=\"#%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6\" aria-label=\"静态文件 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>静态文件</h2>\n<p>socket.io 默认情况下会通过 socket.io-client 包提供 socket.io.min.js 和 socket.io.js.map 下载\n运行实例 app.js</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">let app = require(&#39;http&#39;).createServer()\nlet io = require(&#39;socket.io&#39;)(app)\n\napp.listen(3000);</code></pre></div>\n<p>浏览器访问<code class=\"language-text\">http://localhost:3000/socket.io/socket.io.js</code>可以加载压缩的源码，访问<code class=\"language-text\">http://localhost:3000/socket.io/socket.io.js.map</code>加载 sourcemap</p>\n<p>我们可以改变这种行为</p>\n<h3 id=\"禁用-socketiojs-下载\"><a href=\"#%E7%A6%81%E7%94%A8-socketiojs-%E4%B8%8B%E8%BD%BD\" aria-label=\"禁用 socketiojs 下载 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>禁用 socket.io.js 下载</h3>\n<p>方法 1: 实例化时传入控制参数<code class=\"language-text\">serveClient</code>值 false</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">let io = require(&#39;socket.io&#39;)(app, {\n  serveClient: false\n})</code></pre></div>\n<p>方法 2: 调用函数<code class=\"language-text\">serverClient</code></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">let app = require(&#39;http&#39;).createServer()\nlet io = require(&#39;socket.io&#39;)()\nio.serveClient(false)\nio.listen(app) // 或者 io.attach(app)</code></pre></div>\n<blockquote>\n<p>如果在调用函数前服务已绑定 http.Server, 该方法将不起作用</p>\n</blockquote>\n<p>禁用后再次访问将提示<code class=\"language-text\">{&quot;code&quot;:0,&quot;message&quot;:&quot;Transport unknown&quot;}</code></p>\n<h3 id=\"修改静态文件路径\"><a href=\"#%E4%BF%AE%E6%94%B9%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84\" aria-label=\"修改静态文件路径 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>修改静态文件路径</h3>\n<p>socket.io.js 路径可以改变，其默认路径为 /socket.io。</p>\n<p>实例化时传参</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">let io = require(&#39;socket.io&#39;)(app, {\n  path: &#39;/io&#39;\n})</code></pre></div>\n<p>调用函数<code class=\"language-text\">path</code></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">let app = require(&#39;http&#39;).createServer()\nlet io = require(&#39;socket.io&#39;)()\nio.path(&#39;/io&#39;)\nio.listen(app)</code></pre></div>\n<blockquote>\n<p>如果在调用函数前服务已绑定 http.Server, 该方法将不起作用</p>\n</blockquote>\n<h2 id=\"安全策略\"><a href=\"#%E5%AE%89%E5%85%A8%E7%AD%96%E7%95%A5\" aria-label=\"安全策略 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>安全策略</h2>\n<p>socket.io 提供了两种安全策略</p>\n<h3 id=\"allowrequest\"><a href=\"#allowrequest\" aria-label=\"allowrequest permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>allowRequest</h3>\n<p>函数<code class=\"language-text\">allowRequest</code>有两个参数，第一个参数为收到的握手包 (http.request) 对象，作为判断依据，success), err 是错误对象，success 为 boolean, false 表示阻止建立连接</p>\n<p>前端请求带上 token</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">let socket = io(&#39;http://localhost:3000?token=abc&#39;)\nsocket.on(&#39;connect&#39;, () =&gt; {\n  console.log(&#39;connect&#39;)\n})\nsocket.on(&#39;connect_error&#39;, err =&gt; {\n  socket.disconnect()\n  console.log(&#39;connect_error&#39;, err)\n})</code></pre></div>\n<p>后端 allowRequest 根据 token 判断是否继续</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">let app = require(&#39;http&#39;).createServer()\nlet io = require(&#39;socket.io&#39;)(app, {\n  allowRequest: (req, cb) =&gt; {\n    if (req._query &amp;&amp; req._query.token === &#39;abc&#39;) return cb(null, true)\n    cb(null, false)\n  }\n});</code></pre></div>\n<h3 id=\"origins\"><a href=\"#origins\" aria-label=\"origins permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>origins</h3>\n<p>可以对源进行限制</p>\n<ol>\n<li>实例化时限制源</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">let app = require(&#39;http&#39;).createServer()\nlet io = require(&#39;socket.io&#39;)(app, {\n  origins: &#39;http://localhost:3000&#39;\n})</code></pre></div>\n<ol start=\"2\">\n<li>origins 函数设置源</li>\n</ol>\n<p>origins 函数有两种形式\norigins(string):  设置运行的源\norigins(string, fn(err, success)): 通过函数判断源是否允许</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">io.origins(&#39;http://localhost:*&#39;)\n\nio.origins((origin, cb) =&gt; {\n  if (origin === &#39;http://localhost:3000/&#39;) return cb(null, true)\n  cb(null, false)\n})</code></pre></div>\n<h2 id=\"名称空间\"><a href=\"#%E5%90%8D%E7%A7%B0%E7%A9%BA%E9%97%B4\" aria-label=\"名称空间 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>名称空间</h2>\n<p>名称空间用来对服务端 / 客户端的连接隔离，有些地方，也称呼名称空间 (namespace) 为通道 (channel)。下面举例对其意义进行说明</p>\n<p>我们需要实现一个协同应用，这个应用有两个功能：</p>\n<ul>\n<li>协同编辑：多个用户可以同时编辑一个文档</li>\n<li>消息：用户间可以发送消息</li>\n</ul>\n<p>用 socket.io 实现这个应用，有如下几种形式</p>\n<ul>\n<li>完全独立：协同编辑有一个独立服务 edit.socket.test, 消息系统一个独立服务 message.socket.test</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">let editSocket = io(&#39;edit.socket.test&#39;)\nlet messageSocket = io(&#39;message.socket.test&#39;)</code></pre></div>\n<ul>\n<li>名称空间：只运行一个独立服务，通过名称空间进行隔离</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">let app = require(&#39;http&#39;).createServer()\nlet io = require(&#39;socket.io&#39;)(app)\nlet editServer = io.of(&#39;/edit&#39;)\nlet messsageServer = io.of(&#39;/message&#39;)\neditServer.on(&#39;connection&#39;, socket =&gt; {\n  // 编辑相关\n})\nmesssageServer.on(&#39;connection&#39;, socket =&gt; {\n  / 消息相关\n})\n\nlet editSocket = io(&#39;socket.test/edit&#39;)\nlet messageSocket = io(&#39;socket.test/message&#39;)</code></pre></div>\n<ul>\n<li>事件名约定：通过为事件名添加进行隔离</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">let app = require(&#39;http&#39;).createServer()\nlet io = require(&#39;socket.io&#39;)(app)\n\nio.on(&#39;connection&#39;, socket =&gt; {\n  // 编辑相关\n  io.emit(&#39;edit:test&#39;)\n  io.on(&#39;edit:test&#39;, data =&gt; {\n\n  })\n  // 消息相关\n  io.emit(&#39;message:test&#39;)\n  io.on(&#39;message:test&#39;, data =&gt; {\n\n  })\n}</code></pre></div>\n<p>通过事件名约定程序的侵入性太大，不利于拆分和重组，不推荐。 而完全独立的模式需要使用两个 socket 连接，即浪费浏览器允许的并发连接数，又更多消耗服务器资源。使用名称空间即能实现很好的隔离，又不会对资源造成浪费。</p>\n<h3 id=\"默认名称空间\"><a href=\"#%E9%BB%98%E8%AE%A4%E5%90%8D%E7%A7%B0%E7%A9%BA%E9%97%B4\" aria-label=\"默认名称空间 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>默认名称空间</h3>\n<p>socket.io 实例化时自动绑定路径为<code class=\"language-text\">/</code>的名称空间</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">let app = require(&#39;http&#39;).createServer()\nlet io = require(&#39;socket.io&#39;)(app)\n\nio.sockets // io.of(&#39;/&#39;).sockets\nio.emit // 代理 io.of(&#39;/&#39;).emit, 类似函数有&#39;to&#39;, &#39;in&#39;, &#39;use&#39;, &#39;send&#39;, &#39;write&#39;, &#39;clients&#39;, &#39;compress&#39;</code></pre></div>\n<h2 id=\"中间件\"><a href=\"#%E4%B8%AD%E9%97%B4%E4%BB%B6\" aria-label=\"中间件 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>中间件</h2>\n<p>socket.io 的名空间通过 use 注册中间件，中间件在客户端与服务端建立连接成功后，connet 事件派发前调用<strong>一次</strong>。</p>\n<p>利用中间件数据校验</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">io.use((socket, next) =&gt; {\n  if (socket.request.headers.cookie) return next()\n  next(new Error(&#39;Authentication error&#39;))\n})</code></pre></div>\n<p>利用中间件提取或转换数据</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">io.use((socket, next) =&gt; {\n  getInfo(socket.request.query.id, (err, data) =&gt; {\n    if (err) return next(err)\n\tsocket.custom = data\n\tnext()\n  })\n})</code></pre></div>\n<h3 id=\"与-allowrequest-对比\"><a href=\"#%E4%B8%8E-allowrequest-%E5%AF%B9%E6%AF%94\" aria-label=\"与 allowrequest 对比 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>与 allowRequest 对比</h3>\n<p>allowRequest 可以进行一些校验，提取，为什么还要需要中间件？</p>\n<ol>\n<li>allowRequest 传入的 http.request 实例，而中间件出入数据 socket 实例，socket 实例包含 request 实例，且有更多信息</li>\n<li>中间件直接支持多个异步流程嵌套，而 allowRequest 需要自己实现</li>\n</ol>\n<h3 id=\"与-connection-事件对比\"><a href=\"#%E4%B8%8E-connection-%E4%BA%8B%E4%BB%B6%E5%AF%B9%E6%AF%94\" aria-label=\"与 connection 事件对比 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>与 connection 事件对比</h3>\n<p>connection 事件也传入 socket, 也可以进行数验，提取，为什么还要需要中间件？</p>\n<ol>\n<li>中间件直接支持多个异步流程嵌套，而 allowRequest 需要自己实现</li>\n<li>中间件成功后到 connection 事件发送成功前，socket.io 还做了一些工作，比如把 socket 实例添加到 connected 对象中，加入聊天室等。如果因为权限中断连接，在中间件中处理更省资源。</li>\n</ol>\n<h2 id=\"聊天室\"><a href=\"#%E8%81%8A%E5%A4%A9%E5%AE%A4\" aria-label=\"聊天室 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>聊天室</h2>\n<p>聊天室是对当前连接的 socket 集合根据特定规则进行归组，方便群发消息。可以类比 QQ 群的概率。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">socket.join(&#39;room name&#39;) // 进入\nsocket.leave(&#39;room name&#39;) // 退出</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">io.to(&#39;some room&#39;).emit(&#39;some event&#39;) // io.to 与 io.in 同义，向某个聊天室的所有成员发送消息</code></pre></div>\n<h3 id=\"默认聊天室\"><a href=\"#%E9%BB%98%E8%AE%A4%E8%81%8A%E5%A4%A9%E5%AE%A4\" aria-label=\"默认聊天室 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>默认聊天室</h3>\n<p>每个 socket 在连接成功后会自动创建一个默认个聊天室，这个聊天室的名字是当前 socket 的 id, 可以通过默认聊天室实现向特定用户发送消息</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">socket.on(&#39;say to someone&#39;, (id, msg) =&gt; {\n  socket.broadcast.to(id).emit(&#39;my message&#39;, msg)\n})</code></pre></div>\n<h2 id=\"消息发送\"><a href=\"#%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81\" aria-label=\"消息发送 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>消息发送</h2>\n<h3 id=\"应答消息\"><a href=\"#%E5%BA%94%E7%AD%94%E6%B6%88%E6%81%AF\" aria-label=\"应答消息 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>应答消息</h3>\n<p>普通消息不需要回应，而应答消息提供了应答机制</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">io.on(&#39;connection&#39;, socket =&gt; {\n  socket.emit(&#39;an event&#39;, { some: &#39;data&#39; }) // 普通消息\n\n  socket.emit(&#39;ferret&#39;, &#39;tobi&#39;, function (data) { // 应答消息\n    console.log(data); // data will be &#39;woot&#39;\n  })\n})</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">socket.on(&#39;ferret&#39;, (name, fn) =&gt; {\n  fn(&#39;woot&#39;)\n})</code></pre></div>\n<h3 id=\"压缩\"><a href=\"#%E5%8E%8B%E7%BC%A9\" aria-label=\"压缩 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>压缩</h3>\n<p><code class=\"language-text\">socket.compress(true)</code>启用压缩，调用后当前连接的所有数据在传递给客户端前都会进行压缩</p>\n<h3 id=\"volatile-标志\"><a href=\"#volatile-%E6%A0%87%E5%BF%97\" aria-label=\"volatile 标志 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>volatile 标志</h3>\n<p>socket.io 在正常情况下对发送的消息进行追踪，确保消息发送成功，而设置 volatile 后发送消息，socket.io 不会对消息追踪，消息可能丢失</p>\n<h3 id=\"分类\"><a href=\"#%E5%88%86%E7%B1%BB\" aria-label=\"分类 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>分类</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">// 客户端发送消息\nsocket.emit(&#39;hello&#39;, &#39;can you hear me?&#39;, 1, 2, &#39;abc&#39;);\n\n// 向所有连接的客户端（除了自己）发送消息\nsocket.broadcast.emit(&#39;broadcast&#39;, &#39;hello friends!&#39;);\n\n// 向 game 聊天室发送消息，自己不算\nsocket.to(&#39;game&#39;).emit(&#39;nice game&#39;, &quot;let&#39;s play a game&quot;);\n\n// 同时向 game1 和 game2 聊天室发送消息，自己不算\nsocket.to(&#39;game1&#39;).to(&#39;game2&#39;).emit(&#39;nice game&#39;, &quot;let&#39;s play a game (too)&quot;);\n\n// 向 game 聊天室的所有人发送消息\nio.in(&#39;game&#39;).emit(&#39;big-announcement&#39;, &#39;the game will start soon&#39;);\n\n// 发送消息到&lt;socketid&gt;客户端\nsocket.to(&lt;socketid&gt;).emit(&#39;hey&#39;, &#39;I just met you&#39;);\n\n// 发送应答消息\nsocket.emit(&#39;question&#39;, &#39;do you think so?&#39;, function (answer) {});</code></pre></div>","excerpt":"静态文件 socket.io 默认情况下会通过 socket.io-client 包提供 socket.io.min.js 和 socket.io.js.map 下载\n运行实例 app.js 浏览器访问 可以加载压缩的源码，访问 加载 sourcemap…","timeToRead":5,"headings":[{"value":"静态文件","depth":2},{"value":"禁用 socket.io.js 下载","depth":3},{"value":"修改静态文件路径","depth":3},{"value":"安全策略","depth":2},{"value":"allowRequest","depth":3},{"value":"origins","depth":3},{"value":"名称空间","depth":2},{"value":"默认名称空间","depth":3},{"value":"中间件","depth":2},{"value":"与 allowRequest 对比","depth":3},{"value":"与 connection 事件对比","depth":3},{"value":"聊天室","depth":2},{"value":"默认聊天室","depth":3},{"value":"消息发送","depth":2},{"value":"应答消息","depth":3},{"value":"压缩","depth":3},{"value":"volatile 标志","depth":3},{"value":"分类","depth":3}],"frontmatter":{"title":"socket.io 系列三：深入学习","notoc":null,"excerpt":"socket.io 提供了基于事件的实时双向通讯，本文将对其进行详细介绍(三)","date":"April 18th 2017","rawDate":"2017-04-18"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/socket-iozhi-san-shen-ru-xue-xi/","prev":{"fields":{"slug":"/socket-iozhi-er-ji-ben-ying-yong/"},"frontmatter":{"title":"socket.io 系列二：基本应用","draft":null,"tags":["howto","socket.io","javascript"]}},"next":{"fields":{"slug":"/logstash-grok-wen-ben-jie-xi/"},"frontmatter":{"title":"探究 logstash grok 文本解析","draft":null,"tags":["howto","elk","grok","logstash"]}}}}