{"data":{"site":{"siteMetadata":{"title":"Sigoden | Blog","siteUrl":"https://blog.sigoden.com","siteAuthor":"sigoden","githubUrl":"https://github.com/sigoden"}},"markdownRemark":{"html":"<h2 id=\"最小的镜像是？\"><a href=\"#%E6%9C%80%E5%B0%8F%E7%9A%84%E9%95%9C%E5%83%8F%E6%98%AF%EF%BC%9F\" aria-label=\"最小的镜像是？ permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>最小的镜像是？</h2>\n<p><a href=\"https://hub.docker.com/_/scratch/\">scratch</a></p>\n<p>scratch 镜像很赞，它简洁、小巧而且快速， 它没有 bug、安全漏洞、延缓的代码或技术债务。这是因为它基本上是空的。\nscratch 镜像不能执行一些常规的 <code class=\"language-text\">pull</code>, <code class=\"language-text\">run</code>, <code class=\"language-text\">tag</code> 等 docker 命令，只能通过 Dockerfile 执行 <code class=\"language-text\">FROM scratch</code> 间接引用。\n而且该指令并不生成新的数据层，相当于 metadata。</p>\n<p>它适用于直接包装单个命令，类似于:</p>\n<div class=\"gatsby-highlight\" data-language=\"dockerfile\"><pre class=\"language-dockerfile\"><code class=\"language-dockerfile\">FROM scratch\nCOPY hello /\nCMD [&quot;/hello&quot;]</code></pre></div>\n<h2 id=\"最小的操作系统镜像？\"><a href=\"#%E6%9C%80%E5%B0%8F%E7%9A%84%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%95%9C%E5%83%8F%EF%BC%9F\" aria-label=\"最小的操作系统镜像？ permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>最小的操作系统镜像？</h2>\n<p><a href=\"https://hub.docker.com/_/alpine/\">alpine</a></p>\n<p>alpine 镜像封装了最小的操作系统 <a href=\"https://www.alpinelinux.org\">alpine</a>, 体积只用 5M，有包管理器 apk。很适合作为基础镜像，特别适合生产环境，够小又够用。</p>\n<h2 id=\"多阶段构建-？\"><a href=\"#%E5%A4%9A%E9%98%B6%E6%AE%B5%E6%9E%84%E5%BB%BA-%EF%BC%9F\" aria-label=\"多阶段构建 ？ permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>多阶段构建 ？</h2>\n<p><a href=\"https://docs.docker.com/develop/develop-images/multistage-build/#use-multi-stage-builds\">多阶段构建</a>可以用来优化 Dockerfile，减小镜像体积。</p>\n<p>在生产环境中，我们通常只需要用到可执行文件，但为了生成构建该可执行文件，我们常常需要安装一些额外编译工具、库，这造成最后生成的镜像很脏很大。如果能把构建方面的工作和打包应用的工作分开，单一职责，我们就能优雅的得到干净的生产环境镜像了。多阶段构建就是用来完成这项工作。</p>\n<p>以 Go 应用举例</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">FROM golang:1.7.3 as builder\nWORKDIR /go/src/github.com/alexellis/href-counter/\nRUN go get -d -v golang.org/x/net/html  \nCOPY app.go    .\nRUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .\n\nFROM alpine:latest  \nRUN apk --no-cache add ca-certificates\nWORKDIR /root/\nCOPY --from=builder /go/src/github.com/alexellis/href-counter/app .\nCMD [&quot;./app&quot;]  </code></pre></div>\n<p>构建阶段生成可执行文件，封装阶段直接复制前面构建的可执行文件打包成镜像，这样我们就得到干净的小很多的使用生产环境下的应用镜像了。</p>\n<h2 id=\"调整指令顺序会优化构建吗？\"><a href=\"#%E8%B0%83%E6%95%B4%E6%8C%87%E4%BB%A4%E9%A1%BA%E5%BA%8F%E4%BC%9A%E4%BC%98%E5%8C%96%E6%9E%84%E5%BB%BA%E5%90%97%EF%BC%9F\" aria-label=\"调整指令顺序会优化构建吗？ permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>调整指令顺序会优化构建吗？</h2>\n<p>会，Docker 会缓存每部指令执行的数据层，如果检测到没有变动，会优先使用缓存，这能减少构建时间和资源消耗了。</p>\n<p>缓存是有顺序的，如果前面的缓存失效了，后面指令的缓存会被全部抛弃。所以应尽量将 <strong>不容易变动的指令前置，容易变动的指令后置</strong> 。 </p>\n<h2 id=\"构建缓存有哪些注意事项？\"><a href=\"#%E6%9E%84%E5%BB%BA%E7%BC%93%E5%AD%98%E6%9C%89%E5%93%AA%E4%BA%9B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%9F\" aria-label=\"构建缓存有哪些注意事项？ permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>构建缓存有哪些注意事项？</h2>\n<ul>\n<li>\n<p>会实际产生缓存的命令只有 <code class=\"language-text\">RUN</code>, <code class=\"language-text\">COPY</code>, <code class=\"language-text\">ADD</code>，其它指令只会产生临时数据层。</p>\n</li>\n<li>\n<p>Dockerfile 如果有变动，会从变动起始地方抛弃之后所有的缓存。</p>\n</li>\n<li>\n<p><code class=\"language-text\">RUN</code> 是靠 Dockerfile 中该指令的内容来判断缓存失效的。<code class=\"language-text\">RUN apt-get -y update</code> 会使用缓存，不管源是否有更新。</p>\n</li>\n<li>\n<p><code class=\"language-text\">COPY</code> 和 <code class=\"language-text\">ADD</code> 会校验文件是否变动判断缓存失效。</p>\n</li>\n</ul>\n<h2 id=\"构建时如何忽略文件？\"><a href=\"#%E6%9E%84%E5%BB%BA%E6%97%B6%E5%A6%82%E4%BD%95%E5%BF%BD%E7%95%A5%E6%96%87%E4%BB%B6%EF%BC%9F\" aria-label=\"构建时如何忽略文件？ permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>构建时如何忽略文件？</h2>\n<p>使用 <a href=\"https://docs.docker.com/engine/reference/builder/#dockerignore-file\">.dockerignore </a></p>\n<p>默认情况下，docker 会将 Dockerfile 所在的目录的所有文件（递归）全部包含到镜像编译上下文中，里面的一些无用的文件会增加编译时间，如果包含到最终镜像文件中，还会造成镜像不必要臃肿。\n可以在 Dockerfile 所在目录创建 .dockerignore 文件，用以忽略不必要的文件。</p>\n<h2 id=\"dockerfile-如何嵌入文件？\"><a href=\"#dockerfile-%E5%A6%82%E4%BD%95%E5%B5%8C%E5%85%A5%E6%96%87%E4%BB%B6%EF%BC%9F\" aria-label=\"dockerfile 如何嵌入文件？ permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Dockerfile 如何嵌入文件？</h2>\n<div class=\"gatsby-highlight\" data-language=\"docekerfile\"><pre class=\"language-docekerfile\"><code class=\"language-docekerfile\">RUN echo $&#39;server {\\n\\\n    listen          80;\\n\\\n    server_name     example.com;\\n\\\n    location / {\\n\\\n      proxy_pass      http://localhost:8080;\\n\\\n    }\\n\\\n}&#39;\\\n&gt;&gt; /etc/nginx/conf.d/server.conf</code></pre></div>\n<h2 id=\"add-和-copy-的区别？\"><a href=\"#add-%E5%92%8C-copy-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F\" aria-label=\"add 和 copy 的区别？ permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>ADD 和 COPY 的区别？</h2>\n<ul>\n<li>COPY 从文件系统复制文件到镜像</li>\n<li>COPY 优先使用</li>\n<li>ADD 包含了 COPY 的功能</li>\n<li>ADD 复制并解压压缩文件，如 <code class=\"language-text\">ADD rootfs.tar.xz /</code></li>\n<li>ADD 可以从 URL 下载文件到镜像，到并不会解压下载的压缩文件</li>\n</ul>\n<h2 id=\"命令行\"><a href=\"#%E5%91%BD%E4%BB%A4%E8%A1%8C\" aria-label=\"命令行 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>命令行</h2>\n<h3 id=\"一键清理\"><a href=\"#%E4%B8%80%E9%94%AE%E6%B8%85%E7%90%86\" aria-label=\"一键清理 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>一键清理</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">docker system prune</code></pre></div>\n<p>会清理所以没有使用的资源，包括 <code class=\"language-text\">image</code>, <code class=\"language-text\">volume</code>，<code class=\"language-text\">network</code>。</p>\n<h3 id=\"清除无用数据卷\"><a href=\"#%E6%B8%85%E9%99%A4%E6%97%A0%E7%94%A8%E6%95%B0%E6%8D%AE%E5%8D%B7\" aria-label=\"清除无用数据卷 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>清除无用数据卷</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">docker volume rm $(docker volume ls -q -f &quot;dangling=true&quot;)</code></pre></div>\n<h3 id=\"清除退出的容器\"><a href=\"#%E6%B8%85%E9%99%A4%E9%80%80%E5%87%BA%E7%9A%84%E5%AE%B9%E5%99%A8\" aria-label=\"清除退出的容器 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>清除退出的容器</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">docker rm $(docker ps -q -f &quot;status=exited&quot;)</code></pre></div>\n<h3 id=\"清除无标示镜像\"><a href=\"#%E6%B8%85%E9%99%A4%E6%97%A0%E6%A0%87%E7%A4%BA%E9%95%9C%E5%83%8F\" aria-label=\"清除无标示镜像 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>清除无标示镜像</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">docker rmi $(docker images -q -f &quot;dangling=true&quot;)</code></pre></div>\n<h3 id=\"自动移除交互容器\"><a href=\"#%E8%87%AA%E5%8A%A8%E7%A7%BB%E9%99%A4%E4%BA%A4%E4%BA%92%E5%AE%B9%E5%99%A8\" aria-label=\"自动移除交互容器 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>自动移除交互容器</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">docker run -it --rm alpine</code></pre></div>\n<p><code class=\"language-text\">--rm</code> 标志在容器退出时自动删除</p>\n<h3 id=\"表格形式显示时自定义栏目\"><a href=\"#%E8%A1%A8%E6%A0%BC%E5%BD%A2%E5%BC%8F%E6%98%BE%E7%A4%BA%E6%97%B6%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%8F%E7%9B%AE\" aria-label=\"表格形式显示时自定义栏目 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>表格形式显示时自定义栏目</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">docker ps --format &quot;table {{.ID}}\\t {{.Image}}\\t {{.Status}}&quot;</code></pre></div>\n<h3 id=\"使用-json-筛选和打印特定内容\"><a href=\"#%E4%BD%BF%E7%94%A8-json-%E7%AD%9B%E9%80%89%E5%92%8C%E6%89%93%E5%8D%B0%E7%89%B9%E5%AE%9A%E5%86%85%E5%AE%B9\" aria-label=\"使用 json 筛选和打印特定内容 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>使用 JSON 筛选和打印特定内容</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">docker info --format &quot;{{json .Plugins}}&quot; | jq .</code></pre></div>","excerpt":"最小的镜像是？ scratch scratch 镜像很赞，它简洁、小巧而且快速， 它没有 bug、安全漏洞、延缓的代码或技术债务。这是因为它基本上是空的。\nscratch 镜像不能执行一些常规的  ,  ,   等 docker 命令，只能通过 Dockerfile…","timeToRead":4,"headings":[{"value":"最小的镜像是？","depth":2},{"value":"最小的操作系统镜像？","depth":2},{"value":"多阶段构建 ？","depth":2},{"value":"调整指令顺序会优化构建吗？","depth":2},{"value":"构建缓存有哪些注意事项？","depth":2},{"value":"构建时如何忽略文件？","depth":2},{"value":"Dockerfile 如何嵌入文件？","depth":2},{"value":"ADD 和 COPY 的区别？","depth":2},{"value":"命令行","depth":2},{"value":"一键清理","depth":3},{"value":"清除无用数据卷","depth":3},{"value":"清除退出的容器","depth":3},{"value":"清除无标示镜像","depth":3},{"value":"自动移除交互容器","depth":3},{"value":"表格形式显示时自定义栏目","depth":3},{"value":"使用 JSON 筛选和打印特定内容","depth":3}],"frontmatter":{"title":"Docker 一问一答","notoc":null,"excerpt":"介绍并汇总 Docker 使用一些注意事项，技巧，心得","date":"November 15th 2017","rawDate":"2017-11-15"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/docker-faq/","prev":{"fields":{"slug":"/dockerfile-entrypoint-vs-cmd/"},"frontmatter":{"title":"对比分析 Dockerfile 中的 ENTRYPOINT 和 CMD","draft":false,"tags":["options","docker"]}},"next":{"fields":{"slug":"/how-to-use-getopt-to-build-cli/"},"frontmatter":{"title":"在 Bash 中使用 getopt 解析命令行参数","draft":false,"tags":["howto","linux","bash"]}}}}