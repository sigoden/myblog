{"data":{"site":{"siteMetadata":{"title":"Sigoden | Blog","siteUrl":"https://blog.sigoden.com","siteAuthor":"sigoden","githubUrl":"https://github.com/sigoden"}},"markdownRemark":{"html":"<h2 id=\"介绍\"><a href=\"#%E4%BB%8B%E7%BB%8D\" aria-label=\"介绍 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>介绍</h2>\n<p>键空间通知使得客户端可以通过订阅频道或模式， 来接收那些以某种方式改动 了 Redis 数据集的事件。\n比如说，对 0 号数据库的键 mykey 过期时，系统将分发两条消息， 相当于执行以下两个 PUBLISH 命令：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">PUBLISH __keyspace@0__:mykey expired\nPUBLISH __keyevent@0__:expired mykey</code></pre></div>\n<p>订阅第一个频道<code class=\"language-text\">__keyspace@0__:mykey</code> 可以接收 0 号数据库中所有修改键 mykey 的事件， 而订阅第二个频道 <code class=\"language-text\">__keyevent@0__:expired</code>则可以接收 0 号数据库中所有执行 expired 命令的键。 以 keyspace 为前缀的频道被称为键空间通知（key-space notification）， 而以 keyevent 为前缀的频道则被称为键事件通知（key-event notification）。</p>\n<h2 id=\"配置\"><a href=\"#%E9%85%8D%E7%BD%AE\" aria-label=\"配置 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>配置</h2>\n<p>因为开启键空间通知功能需要消耗一些 CPU ，所以在默认配置下， 该功能处于关闭状态。可以通过修改 redis.conf 文件，或者直接使用 CONFIG SET 命令来开启或关闭键空间通知功能：</p>\n<ul>\n<li>当 notify-keyspace-events 选项的参数为空字符串时，功能关闭。</li>\n<li>另一方面，当参数不是空字符串时，功能开启。</li>\n</ul>\n<p>notify-keyspace-events 字符选项</p>\n<ul>\n<li>K: 键空间通知，所有通知以 <strong>keyspace@<db></strong> 为前缀</li>\n<li>E: 键事件通知，所有通知以 <strong>keyevent@<db></strong> 为前缀</li>\n<li>g: DEL 、 EXPIRE 、 RENAME 等类型无关的通用命令的通知</li>\n<li>$: 字符串命令的通知</li>\n<li>l: 列表命令的通知</li>\n<li>s: 集合命令的通知</li>\n<li>h: 哈希命令的通知</li>\n<li>z: 有序集合命令的通知</li>\n<li>x: 过期事件：每当有过期键被删除时发送</li>\n<li>e: 驱逐 (evict) 事件：每当有键因为 maxmemory 政策而被删除时发送</li>\n<li>A: 参数 g$lshzxe 的别名</li>\n</ul>\n<p>输入的参数中至少要有一个 K 或者 E ， 否则的话， 不管其余的参数是什么， 都不会有任何通知被分发。举个例子， 如果只想订阅键空间中和字符串过期的通知， 那么参数就应该设为 K$e ， 诸如此类。将参数设为字符串 \"AKE\" 表示发送所有类型的通知。</p>\n<h2 id=\"注意\"><a href=\"#%E6%B3%A8%E6%84%8F\" aria-label=\"注意 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>注意</h2>\n<p>Redis 使用以下两种方式删除过期的键：</p>\n<ul>\n<li>当一个键被访问时，程序会对这个键进行检查，如果键已经过期，那么该键将被删除。底层系统会在后台渐进地查找并删除那些过期的键，从而处理那些已经过期、但是不会被访问到的键。</li>\n<li>当过期键被以上两个程序的任意一个发现、 并且将键从数据库中删除时， Redis 会产生一个 expired 通知。</li>\n</ul>\n<p>Redis 并不保证生存时间（TTL）变为 0 的键会立即被删除：如果程序没有访问这个过期键， 或者带有生存时间的键非常多的话，那么在键的生存时间变为 0 ， 直到键真正被删除这中间，可能会有一段比较显著的时间间隔。</p>\n<p>因此，Redis 产生 expired 通知的时间为过期键被删除的时候，而不是键的生存时间变为 0 的时候。如果 Redis 正确配置且负载合理的，延时不会超超过 1s。</p>\n<p>此外，因为 Redis 目前的订阅与发布功能采取的是发送即忘（fire and forget）策略，所以如果你的程序需要可靠事件通知（reliable notification of events），那么目前的键空间通知可能并不适合你： 当订阅事件的客户端断线时，它会丢失所有在断线期间分发给它的事件。针对这个问题，可以开启多个客户端连接来提高可靠性，因为 Redis 会通知所有订阅了的客户端。</p>\n<h2 id=\"实现\"><a href=\"#%E5%AE%9E%E7%8E%B0\" aria-label=\"实现 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>实现</h2>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var Redis = require(&#39;ioredis&#39;);\nvar redis = new Redis();\n\n// 订阅 subscribe: 订阅具体键名，支持一次可以订阅多个\nredis.subscribe(&#39;__keyspace@0__:mykey1&#39;, &#39;__keyspace@0__:mykey2&#39;, function (err, count) {})\n\n// 模式匹配订阅 psubscribe: 匹配模式订阅\nredis.psubscribe(&#39;__keyspace@*:order*&#39;, function (err, count) {});\n\n// 普通订阅通知处理\nredis.on(&#39;message&#39;, function (channel, message) {\n  console.log(&#39;Receive message %s from channel %s&#39;, message, channel);\n});\n\n// 模式匹配订阅通知处理\nredis.on(&#39;pmessage&#39;, function (channel, key, message) {\n  console.log(&#39;Receive pmessage %s on key %s from channel %s&#39;, message, key, channel);\n});</code></pre></div>\n<h2 id=\"测试\"><a href=\"#%E6%B5%8B%E8%AF%95\" aria-label=\"测试 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>测试</h2>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">redis-cli config set notify-keyspace-events AKE\nredis-cli\n&gt; setex mykey1 1 0\n&gt; setex mykey2 1 0\n&gt; setex order:123456 1 0\n&gt; setex order:123457 1 0</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Receive message set from channel __keyspace@0__:mykey1\nReceive message expire from channel __keyspace@0__:mykey1\nReceive message expired from channel __keyspace@0__:mykey1\nReceive message set from channel __keyspace@0__:mykey2\nReceive message expire from channel __keyspace@0__:mykey2\nReceive message expired from channel __keyspace@0__:mykey2\nReceive pmessage set on key __keyspace@0__:order:123456 from channel __keyspace@*:order*\nReceive pmessage expire on key __keyspace@0__:order:123456 from channel __keyspace@*:order*\nReceive pmessage expired on key __keyspace@0__:order:123456 from channel __keyspace@*:order*\nReceive pmessage set on key __keyspace@0__:order:123457 from channel __keyspace@*:order*\nReceive pmessage expire on key __keyspace@0__:order:123457 from channel __keyspace@*:order*\nReceive pmessage expired on key __keyspace@0__:order:123457 from channel __keyspace@*:order*</code></pre></div>\n<h2 id=\"多实例\"><a href=\"#%E5%A4%9A%E5%AE%9E%E4%BE%8B\" aria-label=\"多实例 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>多实例</h2>\n<p>单个实例可能断线，致使错过了接收延时消息。我们可以通过多实例尽可能的提高可靠性。</p>\n<p>Redis 会将通知推送给所有合适的监听者，所以多实例时会收到多份通知，但我们只需要一个处理者。针对这个问题，我们要通过锁来处理。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var Redis = require(&#39;ioredis&#39;);\nvar sub = new Redis();\nvar client = new Redis();\nvar lock = require(&#39;ioredis-lock&#39;).createLock(client);\n\nsub.psubscribe(&#39;__keyspace@0__:order*&#39;, function (err, count) {});\n\nsub.on(&#39;pmessage&#39;, function (channel, key, message) {\n  if (channel === &#39;__keyspace@0__:order*&#39;) {\n    lock.acquire(key, function (err) {\n      if (err) return // 获取锁失败，返回\n      console.log(&#39;handle notification %s&#39;, key) // 获取锁成功，处理通知\n    })\n  }\n});</code></pre></div>","excerpt":"介绍 键空间通知使得客户端可以通过订阅频道或模式， 来接收那些以某种方式改动 了 Redis 数据集的事件。\n比如说，对 0 号数据库的键 mykey 过期时，系统将分发两条消息， 相当于执行以下两个 PUBLISH 命令： 订阅第一个频道  可以接收…","timeToRead":2,"headings":[{"value":"介绍","depth":2},{"value":"配置","depth":2},{"value":"注意","depth":2},{"value":"实现","depth":2},{"value":"测试","depth":2},{"value":"多实例","depth":2}],"frontmatter":{"title":"Redis 延时推送消息","notoc":null,"excerpt":"常常碰到这样的需求：预约前一个小时向短信通知用户不要错过消费，订单超过 24 小时而没有进一步操作自动取消。可以通过 Redis 的键空间通知实现类似需求。","date":"July 5th 2017","rawDate":"2017-07-05"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/redisyan-shi-tui-song-xiao-xi/","prev":{"fields":{"slug":"/webhook-deploy/"},"frontmatter":{"title":"使用 webhook 自动部署","draft":null,"tags":["howto","ci","nodejs"]}},"next":{"fields":{"slug":"/gitbang-zhu-yue-du-kai-yuan-xiang-mu/"},"frontmatter":{"title":"使用 git 阅读开源项目时的小技巧","draft":null,"tags":["tips","git","opensource"]}}}}